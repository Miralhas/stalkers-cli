import shutil
import time
from pathlib import Path

import questionary
import typer
from core.scripts import (execute_ongoing_updates, execute_ps1_script,
                          generate_download_list)
from questionary import Choice
from rich import print
from typing_extensions import Annotated
from stalkers_cli.core.scripts.mass_downloader.check_chapters_count import check_all_novels_count
from stalkers_cli.core.scripts.mass_downloader.re_download import re_download_all
from stalkers_cli.core.scripts.mass_downloader.webnovel_dot_com_scrapper import scrape_and_check_webnovel_dot_com
from utils import open_in_file_explorer

from stalkers_cli.core import all, check_sus
from stalkers_cli.core.scripts.mass_downloader.downloader import \
    download_novels
from stalkers_cli.core.scripts.mass_downloader.format_all_novels_inside_folder import \
    format_and_post
from stalkers_cli.core.scripts.mass_downloader.novel_updates_slug_scrapper import \
    scrape_and_check
from stalkers_cli.utils.helpers import dict_to_xlsx

app = typer.Typer(no_args_is_help=True, add_completion=False)

OPTIONS_HELP_TEXT = {
    "root": "Root folder generated by the lightnovel-crawler script",
    "start": "Chapter number that the script will start downlownding",
    "end": "Chapter number that the script will stop downlownding",
    "range": "Range of chapters that will be downloaded between the scripts",
    "source": "Source from where the chapters will be downloaded (E.g. 'https://novelnext.com/books/the-authors-pov')",
    "sleep": "Sleep between downloads",
    "absolute_root": "Folder where all the novels are stored",
    "rec_list": "Link to a novelupdates novels list (E.g https://www.novelupdates.com/viewlist/126398/ || https://www.novelupdates.com/series-ranking/)",
    "workers": "Number of threads to be used for download"
}

def request(index: int, total: int, novel: Path, failed_requests: list):
    print(f"\n[yellow][{index+1}/{total}][/yellow]: [green]Formating and posting:[/green] [bright_white]{novel.name}[bright_white]")
    request_status  = format_and_post(novel)
    if request_status is not None:
        failed_requests.append({"novel": novel.name, "status": request_status, "path": novel, "reason": request_status})
    time.sleep(2.5)


@app.command("re-dl")
def re_download(
    absolute_root: Annotated[Path,typer.Option("--absolute-root", "-ar", help=OPTIONS_HELP_TEXT["absolute_root"], prompt="Root Folder", exists=True)] = None,
):
    novels_to_re_download = check_all_novels_count(absolute_root)
    re_download_all(novels_to_re_download)


@app.command("check-sus")
def check_all_novels_chapters(
    absolute_root: Annotated[Path,typer.Option("--absolute-root", "-ar", help=OPTIONS_HELP_TEXT["absolute_root"], prompt="Root Folder", exists=True)] = None,
):
    sus_folders = check_sus(absolute_root)
    
    if (not sus_folders):
        return

    folders_to_delete = questionary.checkbox(
        f"\n\nFolders to delete [{len(sus_folders)}]",
        choices=[Choice(title=f"{sus["name"]} - {sus["reason"]}", value=sus["path"]) for sus in sus_folders],
    ).ask()

    if (folders_to_delete is not None):
        for folder_path in folders_to_delete:
            shutil.rmtree(folder_path)  



@app.command("fpost", help="this script formats and post every novel inside the provided folder.")
def fpost(
    absolute_root: Annotated[Path,typer.Option("--absolute-root", "-ar", help=OPTIONS_HELP_TEXT["absolute_root"], prompt="Root Folder", exists=True)] = None,
):
    paths = list(absolute_root.iterdir())
    selected_paths = questionary.checkbox(
        f"\n\nPaths to be formatted [{len(paths)}]",
        choices=[str(path) for path in paths if path.is_dir()]
    ).ask()

    selected_paths = [Path(path) for path in selected_paths]

    failed_requests = []
    
    for index, novel in enumerate(selected_paths):
        request(index=index, total=len(selected_paths), novel=novel, failed_requests=failed_requests)

    while len(failed_requests) > 0:
        failed_requests_checkbox = questionary.checkbox(
            f"\n\nFailed Requests [{len(failed_requests)}]",
            choices=[Choice(title=f'{req["novel"]}: {req["reason"]}', value=req["path"], checked=True) for req in failed_requests]
        ).ask()
        
        failed_requests.clear()

        for index, novel in enumerate(failed_requests_checkbox):
            request(index=index, total=len(failed_requests_checkbox), novel=novel, failed_requests=failed_requests)
    

@app.command("dl-nu", help="Scrape novel slugs on novelupdates.com and download them")
def mass_downloader(
    novel_updates_href: Annotated[str, typer.Option('--href', help=OPTIONS_HELP_TEXT["rec_list"], prompt=True)] = None,
    output: Annotated[Path,typer.Option("--output", "-o", help=OPTIONS_HELP_TEXT["absolute_root"], prompt="output")] = None,
    workers: Annotated[int, typer.Option('--workers', '-w', help=OPTIONS_HELP_TEXT["workers"])] = 5,
    start: Annotated[int, typer.Option('--start', '-s', help=OPTIONS_HELP_TEXT["start"])] = 1,
    end: Annotated[int, typer.Option('--end', '-e', help=OPTIONS_HELP_TEXT["end"], prompt="end page")] = None,
):
    output.mkdir(parents=True, exist_ok=True)
    novels = sorted(scrape_and_check(novel_updates_href, end_page=end, start_page=start), key=lambda novel: novel["slug"])
    responses =  download_novels(novels, output, workers)
    dict_to_xlsx(responses, output, "mass_download_report")


@app.command("dl-wn", help="Scrape novel slugs on webnovel.com and download them")
def mass_downloader(
    href: Annotated[str, typer.Option('--href', help=OPTIONS_HELP_TEXT["rec_list"], prompt=True)] = None,
    output: Annotated[Path,typer.Option("--output", "-o", help=OPTIONS_HELP_TEXT["absolute_root"], prompt="output")] = None,
    workers: Annotated[int, typer.Option('--workers', '-w', help=OPTIONS_HELP_TEXT["workers"])] = 3,
    max: Annotated[int, typer.Option('--max', '-m', help=OPTIONS_HELP_TEXT["end"], prompt="end page")] = None,
):
    output.mkdir(parents=True, exist_ok=True)
    novels = sorted(scrape_and_check_webnovel_dot_com(href, max), key=lambda novel: novel["slug"])
    responses = download_novels(novels, output, workers)
    dict_to_xlsx(responses, output, "mass_download_report")


@app.command("dl-list", help="This script generates a powershell script that automates the downloading of chapters from a given source into sequential ranges. It is useful against sources that have a rate limit.")
def generate_chapters_download_list_script(
    root: Annotated[Path,typer.Option("--root", "-r", help=OPTIONS_HELP_TEXT["root"], prompt="Root Folder", exists=True)] = None,
    start: Annotated[int, typer.Option('--start', '-s', help=OPTIONS_HELP_TEXT["start"], prompt="start index")] = None,
    end: Annotated[int, typer.Option('--end', '-e', help=OPTIONS_HELP_TEXT["end"], prompt="end index")] = None,
    source: Annotated[str, typer.Option('--source', '-src', help=OPTIONS_HELP_TEXT["source"], prompt=True)] = None,
    range: Annotated[int, typer.Option('--range', '-rg', help=OPTIONS_HELP_TEXT["range"])] = 30,
    sleep: Annotated[str, typer.Option('--sleep', help=OPTIONS_HELP_TEXT["sleep"])] = 5,
):
    ps1_script = generate_download_list(
        output=root,
        range_chapters=range,
        source=source,
        start_index=start,
        end_index=end,
        sleep=sleep
    )

    execute = typer.confirm("Execute the generated powershell script?", default=True)
    if (execute):
        execute_ps1_script(ps1_file=ps1_script)

    open_in_file_explorer(root)


@app.command("updates", help="Check all ongoing novels for chapter updates")
def ongoing_updates(
    absolute_root: Annotated[Path,typer.Option("--absolute-root", "-ar", help=OPTIONS_HELP_TEXT["absolute_root"], prompt="Root Folder", exists=True)] = None,
    workers: Annotated[int, typer.Option('--workers', '-w', help=OPTIONS_HELP_TEXT["workers"])] = 5,
):
    responses = execute_ongoing_updates(absolute_root, workers)
    success_responses = [response for response in responses if response["type"] == "SUCCESS"]
    
    if len(success_responses) <= 0:
        print("[green]All ONGOING novels are up to date![/green]")
        return
    
    download_chapters = typer.confirm("Download updates?", default=True)

    if (download_chapters):
        all(responses=success_responses, absolute_root=absolute_root)
        

if __name__ == "__main__":
    app()
