import shutil
import time
from pathlib import Path

import questionary
import typer
from core.scripts import (execute_ongoing_updates, execute_ps1_script,
                          generate_download_list)
from questionary import Choice
from rich import print
from typing_extensions import Annotated
from utils import open_in_file_explorer

from stalkers_cli.core import all, check_sus
from stalkers_cli.core.scripts.mass_downloader.downloader import \
    download_novels
from stalkers_cli.core.scripts.mass_downloader.format_all_novels_inside_folder import \
    format_and_post
from stalkers_cli.core.scripts.mass_downloader.slug_scrapper import \
    scrape_and_check
from stalkers_cli.utils.helpers import dict_to_xlsx

app = typer.Typer(no_args_is_help=True, add_completion=False)

OPTIONS_HELP_TEXT = {
    "root": "Root folder generated by the lightnovel-crawler script",
    "start": "Chapter number that the script will start downlownding",
    "end": "Chapter number that the script will stop downlownding",
    "range": "Range of chapters that will be downloaded between the scripts",
    "source": "Source from where the chapters will be downloaded (E.g. 'https://novelnext.com/books/the-authors-pov')",
    "sleep": "Sleep between downloads",
    "absolute_root": "Folder where all the novels are stored",
    "rec_list": "Link to a novelupdates novels list (E.g https://www.novelupdates.com/viewlist/126398/ || https://www.novelupdates.com/series-ranking/)",
    "workers": "Number of threads to be used for download"
}

@app.command("check-sus")
def check_all_novels_chapters(
    absolute_root: Annotated[Path,typer.Option("--absolute-root", "-ar", help=OPTIONS_HELP_TEXT["absolute_root"], prompt="Root Folder", exists=True)] = None,
):
    sus_folders = check_sus(absolute_root)

    folders_to_delete = questionary.checkbox(
        f"\n\nFolders to delete",
        choices=[Choice(title=f"{sus["name"]} - {sus["reason"]}", value=sus["path"]) for sus in sus_folders],
    ).ask()

    if (folders_to_delete is not None):
        for folder_path in folders_to_delete:
            shutil.rmtree(folder_path)  



@app.command("fpost", help="this script formats and post every novel inside the provided folder.")
def fpost(
    absolute_root: Annotated[Path,typer.Option("--absolute-root", "-ar", help=OPTIONS_HELP_TEXT["absolute_root"], prompt="Root Folder", exists=True)] = None,
):
    paths = list(absolute_root.iterdir())
    selected_paths = questionary.checkbox(
        f"\n\nPaths to be formatted [{len(paths)}]",
        choices=[str(path) for path in paths if path.is_dir()]
    ).ask()

    selected_paths = [Path(path) for path in selected_paths]

    failed_requests = []
    for index, novel in enumerate(selected_paths):
        print(f"\n[yellow][{index+1}/{len(selected_paths)}][/yellow]: [green]Formating and posting:[/green] [bright_white]{novel.name}[bright_white]")
        request_status = format_and_post(novel)
        if not request_status:
            failed_requests.append({"novel": novel.name, "status": request_status, "path": novel})
        time.sleep(5)

    failed_requests = questionary.checkbox(
        f"\n\nFailed Requests [{len(paths)}]",
        choices=[Choice(title=req["novel"], value=req["path"], checked=True, description="RETRY REQUEST") for req in failed_requests]
    ).ask()

    for novel in failed_requests:
        request_status = format_and_post(novel)
        time.sleep(5)
    
    # console = Console()

    # table = Table(
    #     title=f"Failed requests [{len(failed_requests)}]",
    #     show_lines=True,
    #     header_style="bold green",
    #     width=60
    # )

    # table.add_column("Novel", style="green", overflow="ellipsis")
    # table.add_column("Status", style="yellow", overflow="ellipsis")

    # for res in failed_requests:
    #     table.add_row(
    #         res.get("novel"),
    #         str(res.get("status", False)),
    #     )

    # console.print(table)

@app.command("dl", help="Scrape novel slugs on novelupdates.com and download them")
def mass_downloader(
    novel_updates_href: Annotated[str, typer.Option('--href', help=OPTIONS_HELP_TEXT["rec_list"], prompt=True)] = None,
    output: Annotated[Path,typer.Option("--output", "-o", help=OPTIONS_HELP_TEXT["absolute_root"], prompt="output")] = None,
    workers: Annotated[int, typer.Option('--workers', '-w', help=OPTIONS_HELP_TEXT["workers"])] = 5,
    start: Annotated[int, typer.Option('--start', '-s', help=OPTIONS_HELP_TEXT["start"])] = 1,
    end: Annotated[int, typer.Option('--end', '-e', help=OPTIONS_HELP_TEXT["end"], prompt="end page")] = None,
):
    output.mkdir(parents=True, exist_ok=True)
    novels = sorted(scrape_and_check(novel_updates_href, end_page=end, start_page=start), key=lambda novel: novel["slug"])
    responses =  download_novels(novels, output, workers)
    dict_to_xlsx(responses, output, "mass_download_report")


@app.command("dl-list", help="This script generates a powershell script that automates the downloading of chapters from a given source into sequential ranges. It is useful against sources that have a rate limit.")
def generate_chapters_download_list_script(
    root: Annotated[Path,typer.Option("--root", "-r", help=OPTIONS_HELP_TEXT["root"], prompt="Root Folder", exists=True)] = None,
    start: Annotated[int, typer.Option('--start', '-s', help=OPTIONS_HELP_TEXT["start"], prompt="start index")] = None,
    end: Annotated[int, typer.Option('--end', '-e', help=OPTIONS_HELP_TEXT["end"], prompt="end index")] = None,
    source: Annotated[str, typer.Option('--source', '-src', help=OPTIONS_HELP_TEXT["source"], prompt=True)] = None,
    range: Annotated[int, typer.Option('--range', '-rg', help=OPTIONS_HELP_TEXT["range"])] = 30,
    sleep: Annotated[str, typer.Option('--sleep', help=OPTIONS_HELP_TEXT["sleep"])] = 5,
):
    ps1_script = generate_download_list(
        output=root,
        range_chapters=range,
        source=source,
        start_index=start,
        end_index=end,
        sleep=sleep
    )

    execute = typer.confirm("Execute the generated powershell script?", default=True)
    if (execute):
        execute_ps1_script(ps1_file=ps1_script)

    open_in_file_explorer(root)


@app.command("updates", help="")
def ongoing_updates(
    absolute_root: Annotated[Path,typer.Option("--absolute-root", "-ar", help=OPTIONS_HELP_TEXT["absolute_root"], prompt="Root Folder", exists=True)] = None,
):
    responses = execute_ongoing_updates(absolute_root)
    success_responses = [response for response in responses if response["type"] == "SUCCESS"]
    
    if len(success_responses) <= 0:
        print("[green]All ONGOING novels are up to date![/green]")
        return
    
    download_chapters = typer.confirm("Download updates?", default=True)

    if (download_chapters):
        all(responses=success_responses, absolute_root=absolute_root)
        

if __name__ == "__main__":
    app()
